//
//  AKMetalBarStrike.swift
//  AudioKit
//
//  Autogenerated by scripts by Aurelius Prochazka. Do not edit directly.
//  Copyright (c) 2015 Aurelius Prochazka. All rights reserved.
//

import Foundation

/** Physical model approximating the sound of a struck metal bar.

Audio output is a tone similar to a struck metal bar, using a physical model developed from solving the partial differential equation. There are controls over the boundary conditions as well as the bar characteristics.
*/
@objc class AKMetalBarStrike : AKParameter {

    // MARK: - Properties

    private var bar = UnsafeMutablePointer<sp_bar>.alloc(1)

    /** Dimensionless stiffness parameter [Default Value: 3] */
    private var iK: Float = 0

    /** High frequency loss parameter. Keep this small [Default Value: 0.001] */
    private var ib: Float = 0


    /** 30db decay time (in seconds). [Default Value: 3] */
    var decayTime: AKParameter = akp(3) {
        didSet {
            decayTime.bind(&bar.memory.T30)
            dependencies.append(decayTime)
        }
    }

    /** Boundary condition at left end of bar. 1 = clamped, 2 = pivoting, 3 = free [Default Value: 1] */
    var leftBoundaryCondition: AKParameter = akp(1) {
        didSet {
            leftBoundaryCondition.bind(&bar.memory.bcL)
            dependencies.append(leftBoundaryCondition)
        }
    }

    /** Boundary condition at right end of bar. 1 = clamped, 2 = pivoting, 3 = free [Default Value: 1] */
    var rightBoundaryCondition: AKParameter = akp(1) {
        didSet {
            rightBoundaryCondition.bind(&bar.memory.bcR)
            dependencies.append(rightBoundaryCondition)
        }
    }

    /** SPeed of scanning the output location. [Default Value: 0.25] */
    var scan: AKParameter = akp(0.25) {
        didSet {
            scan.bind(&bar.memory.scan)
            dependencies.append(scan)
        }
    }

    /** Position along bar that strike occurs. [Default Value: 0.2] */
    var pos: AKParameter = akp(0.2) {
        didSet {
            pos.bind(&bar.memory.pos)
            dependencies.append(pos)
        }
    }

    /** Normalized strike velocity [Default Value: 500] */
    var vel: AKParameter = akp(500) {
        didSet {
            vel.bind(&bar.memory.vel)
            dependencies.append(vel)
        }
    }

    /** Spatial width of strike. [Default Value: 0.05] */
    var wid: AKParameter = akp(0.05) {
        didSet {
            wid.bind(&bar.memory.wid)
            dependencies.append(wid)
        }
    }


    // MARK: - Initializers

    /** Instantiates the strike with default values
    */
    override init()
    {
        super.init()
        setup()
        bindAll()
    }

    /** Instantiates strike with constants

    - parameter iK: Dimensionless stiffness parameter [Default Value: 3]
    - parameter ib: High frequency loss parameter. Keep this small [Default Value: 0.001]
    */
    init (iK: Float, ib: Float) {
        super.init()
        setup(iK: iK, ib: ib)
        bindAll()
    }

    /** Instantiates the strike with all values

    - parameter decayTime: 30db decay time (in seconds). [Default Value: 3]
    - parameter leftBoundaryCondition: Boundary condition at left end of bar. 1 = clamped, 2 = pivoting, 3 = free [Default Value: 1]
    - parameter rightBoundaryCondition: Boundary condition at right end of bar. 1 = clamped, 2 = pivoting, 3 = free [Default Value: 1]
    - parameter scan: SPeed of scanning the output location. [Default Value: 0.25]
    - parameter pos: Position along bar that strike occurs. [Default Value: 0.2]
    - parameter vel: Normalized strike velocity [Default Value: 500]
    - parameter wid: Spatial width of strike. [Default Value: 0.05]
    - parameter iK: Dimensionless stiffness parameter [Default Value: 3]
    - parameter ib: High frequency loss parameter. Keep this small [Default Value: 0.001]
    */
    convenience init(
        decayTime:              AKParameter,
        leftBoundaryCondition:  AKParameter,
        rightBoundaryCondition: AKParameter,
        scan:                   AKParameter,
        pos:                    AKParameter,
        vel:                    AKParameter,
        wid:                    AKParameter,
        iK:                     Float,
        ib:                     Float)
    {
        self.init(iK: iK, ib: ib)
        self.decayTime              = decayTime
        self.leftBoundaryCondition  = leftBoundaryCondition
        self.rightBoundaryCondition = rightBoundaryCondition
        self.scan                   = scan
        self.pos                    = pos
        self.vel                    = vel
        self.wid                    = wid

        bindAll()
    }

    // MARK: - Internals

    /** Bind every property to the internal strike */
    internal func bindAll() {
        decayTime             .bind(&bar.memory.T30)
        leftBoundaryCondition .bind(&bar.memory.bcL)
        rightBoundaryCondition.bind(&bar.memory.bcR)
        scan                  .bind(&bar.memory.scan)
        pos                   .bind(&bar.memory.pos)
        vel                   .bind(&bar.memory.vel)
        wid                   .bind(&bar.memory.wid)
        dependencies.append(decayTime)
        dependencies.append(leftBoundaryCondition)
        dependencies.append(rightBoundaryCondition)
        dependencies.append(scan)
        dependencies.append(pos)
        dependencies.append(vel)
        dependencies.append(wid)
    }

    /** Internal set up function */
    internal func setup(iK: Float = 3, ib: Float = 0.001) {
        sp_bar_create(&bar)
        sp_bar_init(AKManager.sharedManager.data, bar, iK, ib)
    }

    /** Computation of the next value */
    override func compute() {
        sp_bar_compute(AKManager.sharedManager.data, bar, nil, &leftOutput);
        rightOutput = leftOutput
    }

    /** Release of memory */
    override func teardown() {
        sp_bar_destroy(&bar)
    }
}
