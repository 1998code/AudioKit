//
//  AKAdditiveCosines.swift
//  AudioKit
//
//  Autogenerated by scripts by Aurelius Prochazka. Do not edit directly.
//  Copyright (c) 2015 Aurelius Prochazka. All rights reserved.
//

import Foundation

/** A set of harmonically related cosine partials.

This is used to generate a series of partials from the harmonic series. It comes from the "buzz" family of Csound opcodes, and is capable of producing a rich spectrum of harmonic content, possibly ideal for subtractive synthesis techniques.
*/
@objc class AKAdditiveCosines : AKParameter {

    // MARK: - Properties

    private var gbuzz = UnsafeMutablePointer<sp_gbuzz>.alloc(1)

    /** Phase to start on (in the range 0-1) [Default Value: 0] */
    private var iphs: Float = 0


    /** A cosine table with at least 8192 points is recommended. [Default Value: ] */
    var cosineTable = AKTable.standardSineWave() {
        didSet {
            gbuzz.memory.ft = cosineTable.ftbl
        }
    }

    /** Number of harmonics. [Default Value: 10] */
    var harmonicsCount: AKParameter = akp(10) {
        didSet {
            harmonicsCount.bind(&gbuzz.memory.nharm)
            dependencies.append(harmonicsCount)
        }
    }

    /** Lowest harmonic present. This should be a whole number integer. [Default Value: 1] */
    var firstHarmonicIndex: AKParameter = akp(1) {
        didSet {
            firstHarmonicIndex.bind(&gbuzz.memory.lharm)
            dependencies.append(firstHarmonicIndex)
        }
    }

    /** Multiplier. This determines the relative strength of each harmonic. [Default Value: 1] */
    var partialMultiplier: AKParameter = akp(1) {
        didSet {
            partialMultiplier.bind(&gbuzz.memory.mul)
            dependencies.append(partialMultiplier)
        }
    }

    /** The fundamental frequency (which can be modulated), in Hertz. [Default Value: 220] */
    var fundamentalFrequency: AKParameter = akp(220) {
        didSet {
            fundamentalFrequency.bind(&gbuzz.memory.freq)
            dependencies.append(fundamentalFrequency)
        }
    }

    /** The total amplitude of the output of all the cosines. (Typically a value between 0 and 1). [Default Value: 0.4] */
    var amplitude: AKParameter = akp(0.4) {
        didSet {
            amplitude.bind(&gbuzz.memory.amp)
            dependencies.append(amplitude)
        }
    }


    // MARK: - Initializers

    /** Instantiates the partials with default values
    */
    override init()
    {
        super.init()
        setup()
        bindAll()
    }

    /** Instantiates partials with constants

    - parameter iphs: Phase to start on (in the range 0-1) [Default Value: 0]
    */
    init (iphs: Float) {
        super.init()
        setup(iphs)
        bindAll()
    }

    /** Instantiates the partials with all values

    - parameter cosineTable: A cosine table with at least 8192 points is recommended. 
    - parameter harmonicsCount: Number of harmonics. [Default Value: 10]
    - parameter firstHarmonicIndex: Lowest harmonic present. This should be a whole number integer. [Default Value: 1]
    - parameter partialMultiplier: Multiplier. This determines the relative strength of each harmonic. [Default Value: 1]
    - parameter fundamentalFrequency: The fundamental frequency (which can be modulated), in Hertz. [Default Value: 220]
    - parameter amplitude: The total amplitude of the output of all the cosines. (Typically a value between 0 and 1). [Default Value: 0.4]
    - parameter iphs: Phase to start on (in the range 0-1) [Default Value: 0]
    */
    convenience init(
        cosineTable:          AKTable,
        harmonicsCount:       AKParameter,
        firstHarmonicIndex:   AKParameter,
        partialMultiplier:    AKParameter,
        fundamentalFrequency: AKParameter,
        amplitude:            AKParameter,
        iphs:                 Float)
    {
        self.init(iphs: iphs)
        self.cosineTable          = cosineTable
        self.harmonicsCount       = harmonicsCount
        self.firstHarmonicIndex   = firstHarmonicIndex
        self.partialMultiplier    = partialMultiplier
        self.fundamentalFrequency = fundamentalFrequency
        self.amplitude            = amplitude

        bindAll()
    }

    // MARK: - Internals

    /** Bind every property to the internal partials */
    internal func bindAll() {
        gbuzz.memory.ft = cosineTable.ftbl
        harmonicsCount      .bind(&gbuzz.memory.nharm)
        firstHarmonicIndex  .bind(&gbuzz.memory.lharm)
        partialMultiplier   .bind(&gbuzz.memory.mul)
        fundamentalFrequency.bind(&gbuzz.memory.freq)
        amplitude           .bind(&gbuzz.memory.amp)
        dependencies.append(harmonicsCount)
        dependencies.append(firstHarmonicIndex)
        dependencies.append(partialMultiplier)
        dependencies.append(fundamentalFrequency)
        dependencies.append(amplitude)
    }

    /** Internal set up function */
    internal func setup(iphs: Float = 0) {
        sp_gbuzz_create(&gbuzz)
        sp_gbuzz_init(AKManager.sharedManager.data, gbuzz, cosineTable.ftbl, iphs)
    }

    /** Computation of the next value */
    override func compute() {
        sp_gbuzz_compute(AKManager.sharedManager.data, gbuzz, nil, &leftOutput);
        rightOutput = leftOutput
    }

    /** Release of memory */
    override func teardown() {
        sp_gbuzz_destroy(&gbuzz)
    }
}
