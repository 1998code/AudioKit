//
//  AKAdditiveCosines.swift
//  AudioKit
//
//  Autogenerated by scripts by Aurelius Prochazka on 9/10/15.
//  Copyright (c) 2015 Aurelius Prochazka. All rights reserved.
//

import Foundation

/** A set of harmonically related cosine partials.

This is used to generate a series of partials from the harmonic series. It comes from the "buzz" family of Csound opcodes, and is capable of producing a rich spectrum of harmonic content, possibly ideal for subtractive synthesis techniques.
*/
@objc class AKAdditiveCosines : AKParameter {

    // MARK: - Properties

    private var gbuzz = UnsafeMutablePointer<sp_gbuzz>.alloc(1)

    /** Phase to start on (in the range 0-1) [Default Value: 0] */
    private var iphs: Float = 0


    /** A cosine table with at least 8192 points is recommended. [Default Value: ] */
    var cosineTable = AKTable()

    /** Number of harmonics. [Default Value: 10] */
    var harmonicsCount: AKParameter = akp(10) {
        didSet { harmonicsCount.bind(&gbuzz.memory.nharm) }
    }

    /** Lowest harmonic present. This should be a whole number integer. [Default Value: 1] */
    var firstHarmonicIndex: AKParameter = akp(1) {
        didSet { firstHarmonicIndex.bind(&gbuzz.memory.lharm) }
    }

    /** Multiplier. This determines the relative strength of each harmonic. [Default Value: 1] */
    var partialMultiplier: AKParameter = akp(1) {
        didSet { partialMultiplier.bind(&gbuzz.memory.mul) }
    }

    /** The fundamental frequency (which can be modulated), in Hertz. [Default Value: 220] */
    var fundamentalFrequency: AKParameter = akp(220) {
        didSet { fundamentalFrequency.bind(&gbuzz.memory.freq) }
    }

    /** The total amplitude of the output of all the cosines. (Typically a value between 0 and 1). [Default Value: 0.4] */
    var amplitude: AKParameter = akp(0.4) {
        didSet { amplitude.bind(&gbuzz.memory.amp) }
    }


    // MARK: - Initializers

    /** Instantiates the partials with default values */
    override init()
    {
        super.init()
        setup()
        bindAll()
    }

    /**
    Instantiates partials with constants

    -parameter iphs Phase to start on (in the range 0-1) [Default Value: 0]
 */
    init (iphs iphsInput: Float) {
        super.init()
        setup(iphsInput)
        bindAll()
    }

    /**
    Instantiates the partials with all values

    -parameter harmonicsCount Number of harmonics. [Default Value: 10]
    -parameter firstHarmonicIndex Lowest harmonic present. This should be a whole number integer. [Default Value: 1]
    -parameter partialMultiplier Multiplier. This determines the relative strength of each harmonic. [Default Value: 1]
    -parameter fundamentalFrequency The fundamental frequency (which can be modulated), in Hertz. [Default Value: 220]
    -parameter amplitude The total amplitude of the output of all the cosines. (Typically a value between 0 and 1). [Default Value: 0.4]
    -parameter iphs Phase to start on (in the range 0-1) [Default Value: 0]
    */
    convenience init(
        harmonicsCount       nharmInput: AKParameter,
        firstHarmonicIndex   lharmInput: AKParameter,
        partialMultiplier    mulInput:   AKParameter,
        fundamentalFrequency freqInput:  AKParameter,
        amplitude            ampInput:   AKParameter,
        iphs                 iphsInput:  Float)
    {
        self.init(iphs: iphsInput)
        harmonicsCount       = nharmInput
        firstHarmonicIndex   = lharmInput
        partialMultiplier    = mulInput
        fundamentalFrequency = freqInput
        amplitude            = ampInput

        bindAll()
    }

    // MARK: - Internals

    /** Bind every property to the internal partials */
    internal func bindAll() {
        harmonicsCount      .bind(&gbuzz.memory.nharm)
        firstHarmonicIndex  .bind(&gbuzz.memory.lharm)
        partialMultiplier   .bind(&gbuzz.memory.mul)
        fundamentalFrequency.bind(&gbuzz.memory.freq)
        amplitude           .bind(&gbuzz.memory.amp)
    }

    /** Internal set up function */
    internal func setup(iphs: Float = 0)
 {
        sp_gbuzz_create(&gbuzz)
        sp_gbuzz_init(AKManager.sharedManager.data, gbuzz, cosineTable.ftbl, iphs)
    }

    /** Computation of the next value */
    override func compute() {
        sp_gbuzz_compute(AKManager.sharedManager.data, gbuzz, nil, &leftOutput);
        rightOutput = leftOutput
    }

    /** Release of memory */
    override func teardown() {
        sp_gbuzz_destroy(&gbuzz)
    }
}
