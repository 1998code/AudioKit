//
//  AKOperationGenerator.swift
//  AudioKit
//
//  Autogenerated by scripts by Aurelius Prochazka. Do not edit directly.
//  Copyright (c) 2015 Aurelius Prochazka. All rights reserved.
//

import AVFoundation

/** This is was built using the JC reverb implentation found in FAUST. According to
 the source code, the specifications for this implementation were found on an old
 SAIL DART backup tape.
 This class is derived from the CLM JCRev function, which is based on the use of
 networks of simple allpass and comb delay filters.  This class implements three
 series allpass units, followed by four parallel comb filters, and two
 decorrelation delay lines in parallel at the output. */
public struct AKOperationGenerator: AKNode {

    // MARK: - Properties

    public var avAudioNode: AVAudioNode
    private var internalAU: AKOperationGeneratorAudioUnit?
    private var token: AUParameterObserverToken?

    // MARK: - Initializers
    
    public init(operation: AKOperation, triggered: Bool = false) {
        self.init("\(operation) dup", triggered: triggered)
    }
    
    public init(stereoOperation: AKStereoOperation, triggered: Bool = false) {
        self.init("\(stereoOperation) swap", triggered: triggered)
    }
    
    public init(left: AKOperation, right: AKOperation, triggered: Bool = false) {
        self.init("\(left) \(right)", triggered: triggered)
    }

    /** Initialize this generator node */
    public init(_ sporth: String, triggered: Bool = false) {

        var description = AudioComponentDescription()
        description.componentType         = kAudioUnitType_Effect
        description.componentSubType      = 0x63737467 /*'cstg'*/ 
        description.componentManufacturer = 0x41754b74 /*'AuKt'*/
        description.componentFlags        = 0
        description.componentFlagsMask    = 0

        AUAudioUnit.registerSubclass(
            AKOperationGeneratorAudioUnit.self,
            asComponentDescription: description,
            name: "Local AKOperationGenerator",
            version: UInt32.max)

        self.avAudioNode = AVAudioNode()
        AVAudioUnit.instantiateWithComponentDescription(description, options: []) {
            avAudioUnit, error in

            guard let avAudioUnitEffect = avAudioUnit else { return }

            self.avAudioNode = avAudioUnitEffect
            self.internalAU = avAudioUnitEffect.AUAudioUnit as? AKOperationGeneratorAudioUnit
            AKManager.sharedInstance.engine.attachNode(self.avAudioNode)
            if triggered {
                self.internalAU?.setSporth("0 p \(sporth)")
            } else {
                self.internalAU?.setSporth(sporth)
            }
        }

        guard let tree = internalAU?.parameterTree else { return }


        token = tree.tokenByAddingParameterObserver {
            address, value in

            dispatch_async(dispatch_get_main_queue()) {
            }
        }
    }
    
    public func trigger(parameters: [Double] = []) {
        self.internalAU!.trigger(parameters)
    }
}
